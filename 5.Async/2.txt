异步IO，分很多种，但凡是IO相关的都可以借助swoole来完成。
异步文件系统IO
Swoole\Async::readFile 异步读取小型文件

Swoole\Async::readFile最大可读取4M的文件，如果要读取超大文件，请使用Swoole\Async::read函数

读取文件一定要先存在，不然报错，我准备一个2.text,内容是123456.

//swoole_async_readfile最大可读取4M的文件
//如果要读取超大文件，请使用swoole_async_read函数
Swoole\Async::readFile("./2.text", function($fileName, $content){
    var_dump($fileName, $content);
});
echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6
    7

运行下输出：

$ php async_file.php
done
string(8) "./2.text"
123456

    1
    2
    3
    4

Swoole\Async::writeFile 异步写入少量内容到文件

Swoole\Async::writeFile最大可写入4M, 文件不存在,会自动创建,写入会从头覆盖原先的内容

//文件不存在,会自动创建,最大可写入4M
//会覆盖原先的内容,从头开始覆盖
Swoole\Async::writeFile("./2.text", 'v', function($fileName){
    var_dump($fileName);
});

echo "done" .PHP_EOL;

//再异步读一下，写入成功没？
Swoole\Async::writeFile("./2.text", 'v', function($fileName){
    var_dump($fileName);
});

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12

运行下输出：

$ php async_file.php
done
string(8) "./2.text"
v23456

    1
    2
    3
    4

可以看到会从头写入，原先的1被v给取代了。暂时不知此从尾部写文件。
Swoole\Async::read 异步分段读取大型文件

异步读大文件，分段读取，每次只读$trunk_size个字节，不会占用太多内存。

我准备了一个1.text的文件，大概有 35k 大小。

$trunk_size = 8192;

$offset = 0

Swoole\Async::read("./1.text", function($fileName, $content){
    var_dump($fileName, strlen($content));
    //默认是return true, 会分段,多次执行
    //如果 return false,则执行一次就退出.
    //return false;
}, $trunk_size, $offset);
echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

    $size，读取数据的最大长度，默认为8K = 8192字节
    $offset，偏移文件指针，默认为0，表示从文件头部开始读取。必须大于等于0且小于文件总长度

运行下输出：

$ php async_file.php

done

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(6459)

string(8) "./1.text"
int(0)

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21

会发现了执行了多次，一次一次的异步分段在读取。$size参数设定每一次读取最大的值。
Swoole\Async::write 异步分段写入大内容到文件

Swoole\Async::write是分段读写的。不需要一次性将要写的内容放到内存里，所以只占用少量内存。

我准备了一个1.text的文件，大概有 35k 大小。写入到4.text中。

$content = file_get_contents('./1.text');
Swoole\Async::write("./4.text", $content, -1, function($fileName){
    var_dump($fileName);
});

echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6

运行下输出：

$ php async_file.php
done
string(8) "./4.text"

    1
    2
    3

Swoole\Async::dnsLookup 异步查询DNS

当DNS查询完成时，自动回调指定的callback函数。
当DNS查询失败时，比如域名不存在，回调函数传入的$ip为空

Swoole\Async::dnsLookup("www.baidu.com", function($host, $ip){
    var_dump($host, $ip);
});

Swoole\Async::dnsLookup("www.esd4343.com", function($host, $ip){
    var_dump($host, $ip);
});

echo 'dns done';

    1
    2
    3
    4
    5
    6
    7
    8
    9

执行下：

$ php async.php

dns done

string(13) "www.baidu.com"
string(13) "14.215.177.37"

string(15) "www.esd4343.com"
string(0) ""

    1
    2
    3
    4
    5
    6
    7
    8
    9

异步毫秒定时器
Swoole\Timer::tick 异步毫秒定时器

设置一个间隔时钟定时器，单位是微妙。与after定时器不同的是tick定时器会持续触发，直到调用Swoole\Timer::clear清除。而且可以设置多个相同时间间隔的定时器。

$tmer_id1 = Swoole\Timer::tick(1000, function($timer_id, $params = null){
    echo $timer_id. "timeout\n" . microtime(true);

    //Swoole\Timer::clear($timer_id);
});

//1
var_dump($timer_id1);

// true
var_dump(Swoole\Timer::exists($timer_id1));die;

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

Swoole\Timer::after 异步制定的毫秒时间后执行一次

一个一次性定时器，执行完成后就会销毁,回调函数没有任何参数

$tmer_id2 = Swoole\Timer::after(1000, function(){
     echo "timeout\n" . microtime(true);
});

//2
var_dump($tmer_id2);

// true
var_dump(Swoole\Timer::exists($tmer_id2));die;

    1
    2
    3
    4
    5
    6
    7
    8
    9

Swoole\Timer::clear 删除定时器

使用定时器ID来删除定时器,不能用于清除其他进程的定时器，只作用于当前进程。

$tmer_id1 = Swoole\Timer::tick(1, function($timer_id, $params = null){
    echo $timer_id. "loop" . microtime(true) . PHP_EOL;

    global $a; $a++;

    //1万次后清除
    if ($a >= 10000) {
        Swoole\Timer::clear($timer_id);
    }
});

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

异步MySQL客户端

异步mysql就是异步的去连接数据库。直接上代码。

<?php
/**
 * Created by PhpStorm.
 * User: yangyi
 * Date: 2017/1/5
 * Time: 17:52
 */

$db = new Swoole\Mysql;

//配置文件
$server = array(
    'host' => '127.0.0.1',
    'user' => 'root',
    'password' => '123456',
    'database' => 'user',
);

//concent方法 2个参数，第一个是配置文件，第二个是一个回调函数。
$db->connect($server, function ($db, $result) {
    //$result 连接是否成功，只有为true时才可以执行query查询
    //$result 为false，可以通过`connect_errno`和`connect_error`得到失败的错误码和错误信息
    if ($result === false) {
        var_dump($db->connect_errno, $db->connect_error);
        die;
    }
    $sql = 'select * from ap_room limit 1';

    //query方法就是执行sql的方法
    //第一个参数是sql, 第二个参数是回调函数

    $db->query($sql, function($db, $result) {

        /*
        *  执行失败，$result为false
        *  error属性获得错误信息，errno属性获得错误码
        */
        if ($result === false) {
            var_dump($db->error, $db->errno);
        }

        /*
        * 执行成功
        * SQL为非查询语句(inset,update,delete）$result为true
        * affected_rows 为影响的行数，insert_id 获得
        */
        else if ($result === true ) {
            var_dump($db->affected_rows, $db->insert_id);
        }

        /*
        * 执行成功，SQL为select语句，$result为结果数组
        */
        else {
             var_dump($result);
        }

        //关闭mysql连接
        $db->close();
    });
});

异步IO，分很多种，但凡是IO相关的都可以借助swoole来完成。
异步文件系统IO
Swoole\Async::readFile 异步读取小型文件

Swoole\Async::readFile最大可读取4M的文件，如果要读取超大文件，请使用Swoole\Async::read函数

读取文件一定要先存在，不然报错，我准备一个2.text,内容是123456.

//swoole_async_readfile最大可读取4M的文件
//如果要读取超大文件，请使用swoole_async_read函数
Swoole\Async::readFile("./2.text", function($fileName, $content){
    var_dump($fileName, $content);
});
echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6
    7

运行下输出：

$ php async_file.php
done
string(8) "./2.text"
123456

    1
    2
    3
    4

Swoole\Async::writeFile 异步写入少量内容到文件

Swoole\Async::writeFile最大可写入4M, 文件不存在,会自动创建,写入会从头覆盖原先的内容

//文件不存在,会自动创建,最大可写入4M
//会覆盖原先的内容,从头开始覆盖
Swoole\Async::writeFile("./2.text", 'v', function($fileName){
    var_dump($fileName);
});

echo "done" .PHP_EOL;

//再异步读一下，写入成功没？
Swoole\Async::writeFile("./2.text", 'v', function($fileName){
    var_dump($fileName);
});

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12

运行下输出：

$ php async_file.php
done
string(8) "./2.text"
v23456

    1
    2
    3
    4

可以看到会从头写入，原先的1被v给取代了。暂时不知此从尾部写文件。
Swoole\Async::read 异步分段读取大型文件

异步读大文件，分段读取，每次只读$trunk_size个字节，不会占用太多内存。

我准备了一个1.text的文件，大概有 35k 大小。

$trunk_size = 8192;

$offset = 0

Swoole\Async::read("./1.text", function($fileName, $content){
    var_dump($fileName, strlen($content));
    //默认是return true, 会分段,多次执行
    //如果 return false,则执行一次就退出.
    //return false;
}, $trunk_size, $offset);
echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

    $size，读取数据的最大长度，默认为8K = 8192字节
    $offset，偏移文件指针，默认为0，表示从文件头部开始读取。必须大于等于0且小于文件总长度

运行下输出：

$ php async_file.php

done

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(6459)

string(8) "./1.text"
int(0)

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21

会发现了执行了多次，一次一次的异步分段在读取。$size参数设定每一次读取最大的值。
Swoole\Async::write 异步分段写入大内容到文件

Swoole\Async::write是分段读写的。不需要一次性将要写的内容放到内存里，所以只占用少量内存。

我准备了一个1.text的文件，大概有 35k 大小。写入到4.text中。

$content = file_get_contents('./1.text');
Swoole\Async::write("./4.text", $content, -1, function($fileName){
    var_dump($fileName);
});

echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6

运行下输出：

$ php async_file.php
done
string(8) "./4.text"

    1
    2
    3

Swoole\Async::dnsLookup 异步查询DNS

当DNS查询完成时，自动回调指定的callback函数。
当DNS查询失败时，比如域名不存在，回调函数传入的$ip为空

Swoole\Async::dnsLookup("www.baidu.com", function($host, $ip){
    var_dump($host, $ip);
});

Swoole\Async::dnsLookup("www.esd4343.com", function($host, $ip){
    var_dump($host, $ip);
});

echo 'dns done';

    1
    2
    3
    4
    5
    6
    7
    8
    9

执行下：

$ php async.php

dns done

string(13) "www.baidu.com"
string(13) "14.215.177.37"

string(15) "www.esd4343.com"
string(0) ""

    1
    2
    3
    4
    5
    6
    7
    8
    9

异步毫秒定时器
Swoole\Timer::tick 异步毫秒定时器

设置一个间隔时钟定时器，单位是微妙。与after定时器不同的是tick定时器会持续触发，直到调用Swoole\Timer::clear清除。而且可以设置多个相同时间间隔的定时器。

$tmer_id1 = Swoole\Timer::tick(1000, function($timer_id, $params = null){
    echo $timer_id. "timeout\n" . microtime(true);

    //Swoole\Timer::clear($timer_id);
});

//1
var_dump($timer_id1);

// true
var_dump(Swoole\Timer::exists($timer_id1));die;

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

Swoole\Timer::after 异步制定的毫秒时间后执行一次

一个一次性定时器，执行完成后就会销毁,回调函数没有任何参数

$tmer_id2 = Swoole\Timer::after(1000, function(){
     echo "timeout\n" . microtime(true);
});

//2
var_dump($tmer_id2);

// true
var_dump(Swoole\Timer::exists($tmer_id2));die;

    1
    2
    3
    4
    5
    6
    7
    8
    9

Swoole\Timer::clear 删除定时器

使用定时器ID来删除定时器,不能用于清除其他进程的定时器，只作用于当前进程。

$tmer_id1 = Swoole\Timer::tick(1, function($timer_id, $params = null){
    echo $timer_id. "loop" . microtime(true) . PHP_EOL;

    global $a; $a++;

    //1万次后清除
    if ($a >= 10000) {
        Swoole\Timer::clear($timer_id);
    }
});

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

异步MySQL客户端

异步mysql就是异步的去连接数据库。直接上代码。

<?php
/**
 * Created by PhpStorm.
 * User: yangyi
 * Date: 2017/1/5
 * Time: 17:52
 */

$db = new Swoole\Mysql;

//配置文件
$server = array(
    'host' => '127.0.0.1',
    'user' => 'root',
    'password' => '123456',
    'database' => 'user',
);

//concent方法 2个参数，第一个是配置文件，第二个是一个回调函数。
$db->connect($server, function ($db, $result) {
    //$result 连接是否成功，只有为true时才可以执行query查询
    //$result 为false，可以通过`connect_errno`和`connect_error`得到失败的错误码和错误信息
    if ($result === false) {
        var_dump($db->connect_errno, $db->connect_error);
        die;
    }
    $sql = 'select * from ap_room limit 1';

    //query方法就是执行sql的方法
    //第一个参数是sql, 第二个参数是回调函数

    $db->query($sql, function($db, $result) {

        /*
        *  执行失败，$result为false
        *  error属性获得错误信息，errno属性获得错误码
        */
        if ($result === false) {
            var_dump($db->error, $db->errno);
        }

        /*
        * 执行成功
        * SQL为非查询语句(inset,update,delete）$result为true
        * affected_rows 为影响的行数，insert_id 获得
        */
        else if ($result === true ) {
            var_dump($db->affected_rows, $db->insert_id);
        }

        /*
        * 执行成功，SQL为select语句，$result为结果数组
        */
        else {
             var_dump($result);
        }

        //关闭mysql连接
        $db->close();
    });
});

异步IO，分很多种，但凡是IO相关的都可以借助swoole来完成。
异步文件系统IO
Swoole\Async::readFile 异步读取小型文件

Swoole\Async::readFile最大可读取4M的文件，如果要读取超大文件，请使用Swoole\Async::read函数

读取文件一定要先存在，不然报错，我准备一个2.text,内容是123456.

//swoole_async_readfile最大可读取4M的文件
//如果要读取超大文件，请使用swoole_async_read函数
Swoole\Async::readFile("./2.text", function($fileName, $content){
    var_dump($fileName, $content);
});
echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6
    7

运行下输出：

$ php async_file.php
done
string(8) "./2.text"
123456

    1
    2
    3
    4

Swoole\Async::writeFile 异步写入少量内容到文件

Swoole\Async::writeFile最大可写入4M, 文件不存在,会自动创建,写入会从头覆盖原先的内容

//文件不存在,会自动创建,最大可写入4M
//会覆盖原先的内容,从头开始覆盖
Swoole\Async::writeFile("./2.text", 'v', function($fileName){
    var_dump($fileName);
});

echo "done" .PHP_EOL;

//再异步读一下，写入成功没？
Swoole\Async::writeFile("./2.text", 'v', function($fileName){
    var_dump($fileName);
});

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12

运行下输出：

$ php async_file.php
done
string(8) "./2.text"
v23456

    1
    2
    3
    4

可以看到会从头写入，原先的1被v给取代了。暂时不知此从尾部写文件。
Swoole\Async::read 异步分段读取大型文件

异步读大文件，分段读取，每次只读$trunk_size个字节，不会占用太多内存。

我准备了一个1.text的文件，大概有 35k 大小。

$trunk_size = 8192;

$offset = 0

Swoole\Async::read("./1.text", function($fileName, $content){
    var_dump($fileName, strlen($content));
    //默认是return true, 会分段,多次执行
    //如果 return false,则执行一次就退出.
    //return false;
}, $trunk_size, $offset);
echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

    $size，读取数据的最大长度，默认为8K = 8192字节
    $offset，偏移文件指针，默认为0，表示从文件头部开始读取。必须大于等于0且小于文件总长度

运行下输出：

$ php async_file.php

done

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(6459)

string(8) "./1.text"
int(0)

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21

会发现了执行了多次，一次一次的异步分段在读取。$size参数设定每一次读取最大的值。
Swoole\Async::write 异步分段写入大内容到文件

Swoole\Async::write是分段读写的。不需要一次性将要写的内容放到内存里，所以只占用少量内存。

我准备了一个1.text的文件，大概有 35k 大小。写入到4.text中。

$content = file_get_contents('./1.text');
Swoole\Async::write("./4.text", $content, -1, function($fileName){
    var_dump($fileName);
});

echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6

运行下输出：

$ php async_file.php
done
string(8) "./4.text"

    1
    2
    3

Swoole\Async::dnsLookup 异步查询DNS

当DNS查询完成时，自动回调指定的callback函数。
当DNS查询失败时，比如域名不存在，回调函数传入的$ip为空

Swoole\Async::dnsLookup("www.baidu.com", function($host, $ip){
    var_dump($host, $ip);
});

Swoole\Async::dnsLookup("www.esd4343.com", function($host, $ip){
    var_dump($host, $ip);
});

echo 'dns done';

    1
    2
    3
    4
    5
    6
    7
    8
    9

执行下：

$ php async.php

dns done

string(13) "www.baidu.com"
string(13) "14.215.177.37"

string(15) "www.esd4343.com"
string(0) ""

    1
    2
    3
    4
    5
    6
    7
    8
    9

异步毫秒定时器
Swoole\Timer::tick 异步毫秒定时器

设置一个间隔时钟定时器，单位是微妙。与after定时器不同的是tick定时器会持续触发，直到调用Swoole\Timer::clear清除。而且可以设置多个相同时间间隔的定时器。

$tmer_id1 = Swoole\Timer::tick(1000, function($timer_id, $params = null){
    echo $timer_id. "timeout\n" . microtime(true);

    //Swoole\Timer::clear($timer_id);
});

//1
var_dump($timer_id1);

// true
var_dump(Swoole\Timer::exists($timer_id1));die;

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

Swoole\Timer::after 异步制定的毫秒时间后执行一次

一个一次性定时器，执行完成后就会销毁,回调函数没有任何参数

$tmer_id2 = Swoole\Timer::after(1000, function(){
     echo "timeout\n" . microtime(true);
});

//2
var_dump($tmer_id2);

// true
var_dump(Swoole\Timer::exists($tmer_id2));die;

    1
    2
    3
    4
    5
    6
    7
    8
    9

Swoole\Timer::clear 删除定时器

使用定时器ID来删除定时器,不能用于清除其他进程的定时器，只作用于当前进程。

$tmer_id1 = Swoole\Timer::tick(1, function($timer_id, $params = null){
    echo $timer_id. "loop" . microtime(true) . PHP_EOL;

    global $a; $a++;

    //1万次后清除
    if ($a >= 10000) {
        Swoole\Timer::clear($timer_id);
    }
});

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

异步MySQL客户端

异步mysql就是异步的去连接数据库。直接上代码。

<?php
/**
 * Created by PhpStorm.
 * User: yangyi
 * Date: 2017/1/5
 * Time: 17:52
 */

$db = new Swoole\Mysql;

//配置文件
$server = array(
    'host' => '127.0.0.1',
    'user' => 'root',
    'password' => '123456',
    'database' => 'user',
);

//concent方法 2个参数，第一个是配置文件，第二个是一个回调函数。
$db->connect($server, function ($db, $result) {
    //$result 连接是否成功，只有为true时才可以执行query查询
    //$result 为false，可以通过`connect_errno`和`connect_error`得到失败的错误码和错误信息
    if ($result === false) {
        var_dump($db->connect_errno, $db->connect_error);
        die;
    }
    $sql = 'select * from ap_room limit 1';

    //query方法就是执行sql的方法
    //第一个参数是sql, 第二个参数是回调函数

    $db->query($sql, function($db, $result) {

        /*
        *  执行失败，$result为false
        *  error属性获得错误信息，errno属性获得错误码
        */
        if ($result === false) {
            var_dump($db->error, $db->errno);
        }

        /*
        * 执行成功
        * SQL为非查询语句(inset,update,delete）$result为true
        * affected_rows 为影响的行数，insert_id 获得
        */
        else if ($result === true ) {
            var_dump($db->affected_rows, $db->insert_id);
        }

        /*
        * 执行成功，SQL为select语句，$result为结果数组
        */
        else {
             var_dump($result);
        }

        //关闭mysql连接
        $db->close();
    });
});

echo 33;
异步IO，分很多种，但凡是IO相关的都可以借助swoole来完成。
异步文件系统IO
Swoole\Async::readFile 异步读取小型文件

Swoole\Async::readFile最大可读取4M的文件，如果要读取超大文件，请使用Swoole\Async::read函数

读取文件一定要先存在，不然报错，我准备一个2.text,内容是123456.

//swoole_async_readfile最大可读取4M的文件
//如果要读取超大文件，请使用swoole_async_read函数
Swoole\Async::readFile("./2.text", function($fileName, $content){
    var_dump($fileName, $content);
});
echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6
    7

运行下输出：

$ php async_file.php
done
string(8) "./2.text"
123456

    1
    2
    3
    4

Swoole\Async::writeFile 异步写入少量内容到文件

Swoole\Async::writeFile最大可写入4M, 文件不存在,会自动创建,写入会从头覆盖原先的内容

//文件不存在,会自动创建,最大可写入4M
//会覆盖原先的内容,从头开始覆盖
Swoole\Async::writeFile("./2.text", 'v', function($fileName){
    var_dump($fileName);
});

echo "done" .PHP_EOL;

//再异步读一下，写入成功没？
Swoole\Async::writeFile("./2.text", 'v', function($fileName){
    var_dump($fileName);
});

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12

运行下输出：

$ php async_file.php
done
string(8) "./2.text"
v23456

    1
    2
    3
    4

可以看到会从头写入，原先的1被v给取代了。暂时不知此从尾部写文件。
Swoole\Async::read 异步分段读取大型文件

异步读大文件，分段读取，每次只读$trunk_size个字节，不会占用太多内存。

我准备了一个1.text的文件，大概有 35k 大小。

$trunk_size = 8192;

$offset = 0

Swoole\Async::read("./1.text", function($fileName, $content){
    var_dump($fileName, strlen($content));
    //默认是return true, 会分段,多次执行
    //如果 return false,则执行一次就退出.
    //return false;
}, $trunk_size, $offset);
echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

    $size，读取数据的最大长度，默认为8K = 8192字节
    $offset，偏移文件指针，默认为0，表示从文件头部开始读取。必须大于等于0且小于文件总长度

运行下输出：

$ php async_file.php

done

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(6459)

string(8) "./1.text"
int(0)

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21

会发现了执行了多次，一次一次的异步分段在读取。$size参数设定每一次读取最大的值。
Swoole\Async::write 异步分段写入大内容到文件

Swoole\Async::write是分段读写的。不需要一次性将要写的内容放到内存里，所以只占用少量内存。

我准备了一个1.text的文件，大概有 35k 大小。写入到4.text中。

$content = file_get_contents('./1.text');
Swoole\Async::write("./4.text", $content, -1, function($fileName){
    var_dump($fileName);
});

echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6

运行下输出：

$ php async_file.php
done
string(8) "./4.text"

    1
    2
    3

Swoole\Async::dnsLookup 异步查询DNS

当DNS查询完成时，自动回调指定的callback函数。
当DNS查询失败时，比如域名不存在，回调函数传入的$ip为空

Swoole\Async::dnsLookup("www.baidu.com", function($host, $ip){
    var_dump($host, $ip);
});

Swoole\Async::dnsLookup("www.esd4343.com", function($host, $ip){
    var_dump($host, $ip);
});

echo 'dns done';

    1
    2
    3
    4
    5
    6
    7
    8
    9

执行下：

$ php async.php

dns done

string(13) "www.baidu.com"
string(13) "14.215.177.37"

string(15) "www.esd4343.com"
string(0) ""

    1
    2
    3
    4
    5
    6
    7
    8
    9

异步毫秒定时器
Swoole\Timer::tick 异步毫秒定时器

设置一个间隔时钟定时器，单位是微妙。与after定时器不同的是tick定时器会持续触发，直到调用Swoole\Timer::clear清除。而且可以设置多个相同时间间隔的定时器。

$tmer_id1 = Swoole\Timer::tick(1000, function($timer_id, $params = null){
    echo $timer_id. "timeout\n" . microtime(true);

    //Swoole\Timer::clear($timer_id);
});

//1
var_dump($timer_id1);

// true
var_dump(Swoole\Timer::exists($timer_id1));die;

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

Swoole\Timer::after 异步制定的毫秒时间后执行一次

一个一次性定时器，执行完成后就会销毁,回调函数没有任何参数

$tmer_id2 = Swoole\Timer::after(1000, function(){
     echo "timeout\n" . microtime(true);
});

//2
var_dump($tmer_id2);

// true
var_dump(Swoole\Timer::exists($tmer_id2));die;

    1
    2
    3
    4
    5
    6
    7
    8
    9

Swoole\Timer::clear 删除定时器

使用定时器ID来删除定时器,不能用于清除其他进程的定时器，只作用于当前进程。

$tmer_id1 = Swoole\Timer::tick(1, function($timer_id, $params = null){
    echo $timer_id. "loop" . microtime(true) . PHP_EOL;

    global $a; $a++;

    //1万次后清除
    if ($a >= 10000) {
        Swoole\Timer::clear($timer_id);
    }
});

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

异步MySQL客户端

异步mysql就是异步的去连接数据库。直接上代码。

<?php
/**
 * Created by PhpStorm.
 * User: yangyi
 * Date: 2017/1/5
 * Time: 17:52
 */

$db = new Swoole\Mysql;

//配置文件
$server = array(
    'host' => '127.0.0.1',
    'user' => 'root',
    'password' => '123456',
    'database' => 'user',
);

//concent方法 2个参数，第一个是配置文件，第二个是一个回调函数。
$db->connect($server, function ($db, $result) {
    //$result 连接是否成功，只有为true时才可以执行query查询
    //$result 为false，可以通过`connect_errno`和`connect_error`得到失败的错误码和错误信息
    if ($result === false) {
        var_dump($db->connect_errno, $db->connect_error);
        die;
    }
    $sql = 'select * from ap_room limit 1';

    //query方法就是执行sql的方法
    //第一个参数是sql, 第二个参数是回调函数

    $db->query($sql, function($db, $result) {

        /*
        *  执行失败，$result为false
        *  error属性获得错误信息，errno属性获得错误码
        */
        if ($result === false) {
            var_dump($db->error, $db->errno);
        }

        /*
        * 执行成功
        * SQL为非查询语句(inset,update,delete）$result为true
        * affected_rows 为影响的行数，insert_id 获得
        */
        else if ($result === true ) {
            var_dump($db->affected_rows, $db->insert_id);
        }

        /*
        * 执行成功，SQL为select语句，$result为结果数组
        */
        else {
             var_dump($result);
        }

        //关闭mysql连接
        $db->close();
    });
});

echo 33;
异步IO，分很多种，但凡是IO相关的都可以借助swoole来完成。
异步文件系统IO
Swoole\Async::readFile 异步读取小型文件

Swoole\Async::readFile最大可读取4M的文件，如果要读取超大文件，请使用Swoole\Async::read函数

读取文件一定要先存在，不然报错，我准备一个2.text,内容是123456.

//swoole_async_readfile最大可读取4M的文件
//如果要读取超大文件，请使用swoole_async_read函数
Swoole\Async::readFile("./2.text", function($fileName, $content){
    var_dump($fileName, $content);
});
echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6
    7

运行下输出：

$ php async_file.php
done
string(8) "./2.text"
123456

    1
    2
    3
    4

Swoole\Async::writeFile 异步写入少量内容到文件

Swoole\Async::writeFile最大可写入4M, 文件不存在,会自动创建,写入会从头覆盖原先的内容

//文件不存在,会自动创建,最大可写入4M
//会覆盖原先的内容,从头开始覆盖
Swoole\Async::writeFile("./2.text", 'v', function($fileName){
    var_dump($fileName);
});

echo "done" .PHP_EOL;

//再异步读一下，写入成功没？
Swoole\Async::writeFile("./2.text", 'v', function($fileName){
    var_dump($fileName);
});

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12

运行下输出：

$ php async_file.php
done
string(8) "./2.text"
v23456

    1
    2
    3
    4

可以看到会从头写入，原先的1被v给取代了。暂时不知此从尾部写文件。
Swoole\Async::read 异步分段读取大型文件

异步读大文件，分段读取，每次只读$trunk_size个字节，不会占用太多内存。

我准备了一个1.text的文件，大概有 35k 大小。

$trunk_size = 8192;

$offset = 0

Swoole\Async::read("./1.text", function($fileName, $content){
    var_dump($fileName, strlen($content));
    //默认是return true, 会分段,多次执行
    //如果 return false,则执行一次就退出.
    //return false;
}, $trunk_size, $offset);
echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

    $size，读取数据的最大长度，默认为8K = 8192字节
    $offset，偏移文件指针，默认为0，表示从文件头部开始读取。必须大于等于0且小于文件总长度

运行下输出：

$ php async_file.php

done

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(6459)

string(8) "./1.text"
int(0)

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21

会发现了执行了多次，一次一次的异步分段在读取。$size参数设定每一次读取最大的值。
Swoole\Async::write 异步分段写入大内容到文件

Swoole\Async::write是分段读写的。不需要一次性将要写的内容放到内存里，所以只占用少量内存。

我准备了一个1.text的文件，大概有 35k 大小。写入到4.text中。

$content = file_get_contents('./1.text');
Swoole\Async::write("./4.text", $content, -1, function($fileName){
    var_dump($fileName);
});

echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6

运行下输出：

$ php async_file.php
done
string(8) "./4.text"

    1
    2
    3

Swoole\Async::dnsLookup 异步查询DNS

当DNS查询完成时，自动回调指定的callback函数。
当DNS查询失败时，比如域名不存在，回调函数传入的$ip为空

Swoole\Async::dnsLookup("www.baidu.com", function($host, $ip){
    var_dump($host, $ip);
});

Swoole\Async::dnsLookup("www.esd4343.com", function($host, $ip){
    var_dump($host, $ip);
});

echo 'dns done';

    1
    2
    3
    4
    5
    6
    7
    8
    9

执行下：

$ php async.php

dns done

string(13) "www.baidu.com"
string(13) "14.215.177.37"

string(15) "www.esd4343.com"
string(0) ""

    1
    2
    3
    4
    5
    6
    7
    8
    9

异步毫秒定时器
Swoole\Timer::tick 异步毫秒定时器

设置一个间隔时钟定时器，单位是微妙。与after定时器不同的是tick定时器会持续触发，直到调用Swoole\Timer::clear清除。而且可以设置多个相同时间间隔的定时器。

$tmer_id1 = Swoole\Timer::tick(1000, function($timer_id, $params = null){
    echo $timer_id. "timeout\n" . microtime(true);

    //Swoole\Timer::clear($timer_id);
});

//1
var_dump($timer_id1);

// true
var_dump(Swoole\Timer::exists($timer_id1));die;

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

Swoole\Timer::after 异步制定的毫秒时间后执行一次

一个一次性定时器，执行完成后就会销毁,回调函数没有任何参数

$tmer_id2 = Swoole\Timer::after(1000, function(){
     echo "timeout\n" . microtime(true);
});

//2
var_dump($tmer_id2);

// true
var_dump(Swoole\Timer::exists($tmer_id2));die;

    1
    2
    3
    4
    5
    6
    7
    8
    9

Swoole\Timer::clear 删除定时器

使用定时器ID来删除定时器,不能用于清除其他进程的定时器，只作用于当前进程。

$tmer_id1 = Swoole\Timer::tick(1, function($timer_id, $params = null){
    echo $timer_id. "loop" . microtime(true) . PHP_EOL;

    global $a; $a++;

    //1万次后清除
    if ($a >= 10000) {
        Swoole\Timer::clear($timer_id);
    }
});

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

异步MySQL客户端

异步mysql就是异步的去连接数据库。直接上代码。

<?php
/**
 * Created by PhpStorm.
 * User: yangyi
 * Date: 2017/1/5
 * Time: 17:52
 */

$db = new Swoole\Mysql;

//配置文件
$server = array(
    'host' => '127.0.0.1',
    'user' => 'root',
    'password' => '123456',
    'database' => 'user',
);

//concent方法 2个参数，第一个是配置文件，第二个是一个回调函数。
$db->connect($server, function ($db, $result) {
    //$result 连接是否成功，只有为true时才可以执行query查询
    //$result 为false，可以通过`connect_errno`和`connect_error`得到失败的错误码和错误信息
    if ($result === false) {
        var_dump($db->connect_errno, $db->connect_error);
        die;
    }
    $sql = 'select * from ap_room limit 1';

    //query方法就是执行sql的方法
    //第一个参数是sql, 第二个参数是回调函数

    $db->query($sql, function($db, $result) {

        /*
        *  执行失败，$result为false
        *  error属性获得错误信息，errno属性获得错误码
        */
        if ($result === false) {
            var_dump($db->error, $db->errno);
        }

        /*
        * 执行成功
        * SQL为非查询语句(inset,update,delete）$result为true
        * affected_rows 为影响的行数，insert_id 获得
        */
        else if ($result === true ) {
            var_dump($db->affected_rows, $db->insert_id);
        }

        /*
        * 执行成功，SQL为select语句，$result为结果数组
        */
        else {
             var_dump($result);
        }

        //关闭mysql连接
        $db->close();
    });
});

echo 33;
异步IO，分很多种，但凡是IO相关的都可以借助swoole来完成。
异步文件系统IO
Swoole\Async::readFile 异步读取小型文件

Swoole\Async::readFile最大可读取4M的文件，如果要读取超大文件，请使用Swoole\Async::read函数

读取文件一定要先存在，不然报错，我准备一个2.text,内容是123456.

//swoole_async_readfile最大可读取4M的文件
//如果要读取超大文件，请使用swoole_async_read函数
Swoole\Async::readFile("./2.text", function($fileName, $content){
    var_dump($fileName, $content);
});
echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6
    7

运行下输出：

$ php async_file.php
done
string(8) "./2.text"
123456

    1
    2
    3
    4

Swoole\Async::writeFile 异步写入少量内容到文件

Swoole\Async::writeFile最大可写入4M, 文件不存在,会自动创建,写入会从头覆盖原先的内容

//文件不存在,会自动创建,最大可写入4M
//会覆盖原先的内容,从头开始覆盖
Swoole\Async::writeFile("./2.text", 'v', function($fileName){
    var_dump($fileName);
});

echo "done" .PHP_EOL;

//再异步读一下，写入成功没？
Swoole\Async::writeFile("./2.text", 'v', function($fileName){
    var_dump($fileName);
});

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12

运行下输出：

$ php async_file.php
done
string(8) "./2.text"
v23456

    1
    2
    3
    4

可以看到会从头写入，原先的1被v给取代了。暂时不知此从尾部写文件。
Swoole\Async::read 异步分段读取大型文件

异步读大文件，分段读取，每次只读$trunk_size个字节，不会占用太多内存。

我准备了一个1.text的文件，大概有 35k 大小。

$trunk_size = 8192;

$offset = 0

Swoole\Async::read("./1.text", function($fileName, $content){
    var_dump($fileName, strlen($content));
    //默认是return true, 会分段,多次执行
    //如果 return false,则执行一次就退出.
    //return false;
}, $trunk_size, $offset);
echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

    $size，读取数据的最大长度，默认为8K = 8192字节
    $offset，偏移文件指针，默认为0，表示从文件头部开始读取。必须大于等于0且小于文件总长度

运行下输出：

$ php async_file.php

done

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(6459)

string(8) "./1.text"
int(0)

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21

会发现了执行了多次，一次一次的异步分段在读取。$size参数设定每一次读取最大的值。
Swoole\Async::write 异步分段写入大内容到文件

Swoole\Async::write是分段读写的。不需要一次性将要写的内容放到内存里，所以只占用少量内存。

我准备了一个1.text的文件，大概有 35k 大小。写入到4.text中。

$content = file_get_contents('./1.text');
Swoole\Async::write("./4.text", $content, -1, function($fileName){
    var_dump($fileName);
});

echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6

运行下输出：

$ php async_file.php
done
string(8) "./4.text"

    1
    2
    3

Swoole\Async::dnsLookup 异步查询DNS

当DNS查询完成时，自动回调指定的callback函数。
当DNS查询失败时，比如域名不存在，回调函数传入的$ip为空

Swoole\Async::dnsLookup("www.baidu.com", function($host, $ip){
    var_dump($host, $ip);
});

Swoole\Async::dnsLookup("www.esd4343.com", function($host, $ip){
    var_dump($host, $ip);
});

echo 'dns done';

    1
    2
    3
    4
    5
    6
    7
    8
    9

执行下：

$ php async.php

dns done

string(13) "www.baidu.com"
string(13) "14.215.177.37"

string(15) "www.esd4343.com"
string(0) ""

    1
    2
    3
    4
    5
    6
    7
    8
    9

异步毫秒定时器
Swoole\Timer::tick 异步毫秒定时器

设置一个间隔时钟定时器，单位是微妙。与after定时器不同的是tick定时器会持续触发，直到调用Swoole\Timer::clear清除。而且可以设置多个相同时间间隔的定时器。

$tmer_id1 = Swoole\Timer::tick(1000, function($timer_id, $params = null){
    echo $timer_id. "timeout\n" . microtime(true);

    //Swoole\Timer::clear($timer_id);
});

//1
var_dump($timer_id1);

// true
var_dump(Swoole\Timer::exists($timer_id1));die;

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

Swoole\Timer::after 异步制定的毫秒时间后执行一次

一个一次性定时器，执行完成后就会销毁,回调函数没有任何参数

$tmer_id2 = Swoole\Timer::after(1000, function(){
     echo "timeout\n" . microtime(true);
});

//2
var_dump($tmer_id2);

// true
var_dump(Swoole\Timer::exists($tmer_id2));die;

    1
    2
    3
    4
    5
    6
    7
    8
    9

Swoole\Timer::clear 删除定时器

使用定时器ID来删除定时器,不能用于清除其他进程的定时器，只作用于当前进程。

$tmer_id1 = Swoole\Timer::tick(1, function($timer_id, $params = null){
    echo $timer_id. "loop" . microtime(true) . PHP_EOL;

    global $a; $a++;

    //1万次后清除
    if ($a >= 10000) {
        Swoole\Timer::clear($timer_id);
    }
});

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

异步MySQL客户端

异步mysql就是异步的去连接数据库。直接上代码。

<?php
/**
 * Created by PhpStorm.
 * User: yangyi
 * Date: 2017/1/5
 * Time: 17:52
 */

$db = new Swoole\Mysql;

//配置文件
$server = array(
    'host' => '127.0.0.1',
    'user' => 'root',
    'password' => '123456',
    'database' => 'user',
);

//concent方法 2个参数，第一个是配置文件，第二个是一个回调函数。
$db->connect($server, function ($db, $result) {
    //$result 连接是否成功，只有为true时才可以执行query查询
    //$result 为false，可以通过`connect_errno`和`connect_error`得到失败的错误码和错误信息
    if ($result === false) {
        var_dump($db->connect_errno, $db->connect_error);
        die;
    }
    $sql = 'select * from ap_room limit 1';

    //query方法就是执行sql的方法
    //第一个参数是sql, 第二个参数是回调函数

    $db->query($sql, function($db, $result) {

        /*
        *  执行失败，$result为false
        *  error属性获得错误信息，errno属性获得错误码
        */
        if ($result === false) {
            var_dump($db->error, $db->errno);
        }

        /*
        * 执行成功
        * SQL为非查询语句(inset,update,delete）$result为true
        * affected_rows 为影响的行数，insert_id 获得
        */
        else if ($result === true ) {
            var_dump($db->affected_rows, $db->insert_id);
        }

        /*
        * 执行成功，SQL为select语句，$result为结果数组
        */
        else {
             var_dump($result);
        }

        //关闭mysql连接
        $db->close();
    });
});

echo 33;
异步IO，分很多种，但凡是IO相关的都可以借助swoole来完成。
异步文件系统IO
Swoole\Async::readFile 异步读取小型文件

Swoole\Async::readFile最大可读取4M的文件，如果要读取超大文件，请使用Swoole\Async::read函数

读取文件一定要先存在，不然报错，我准备一个2.text,内容是123456.

//swoole_async_readfile最大可读取4M的文件
//如果要读取超大文件，请使用swoole_async_read函数
Swoole\Async::readFile("./2.text", function($fileName, $content){
    var_dump($fileName, $content);
});
echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6
    7

运行下输出：

$ php async_file.php
done
string(8) "./2.text"
123456

    1
    2
    3
    4

Swoole\Async::writeFile 异步写入少量内容到文件

Swoole\Async::writeFile最大可写入4M, 文件不存在,会自动创建,写入会从头覆盖原先的内容

//文件不存在,会自动创建,最大可写入4M
//会覆盖原先的内容,从头开始覆盖
Swoole\Async::writeFile("./2.text", 'v', function($fileName){
    var_dump($fileName);
});

echo "done" .PHP_EOL;

//再异步读一下，写入成功没？
Swoole\Async::writeFile("./2.text", 'v', function($fileName){
    var_dump($fileName);
});

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12

运行下输出：

$ php async_file.php
done
string(8) "./2.text"
v23456

    1
    2
    3
    4

可以看到会从头写入，原先的1被v给取代了。暂时不知此从尾部写文件。
Swoole\Async::read 异步分段读取大型文件

异步读大文件，分段读取，每次只读$trunk_size个字节，不会占用太多内存。

我准备了一个1.text的文件，大概有 35k 大小。

$trunk_size = 8192;

$offset = 0

Swoole\Async::read("./1.text", function($fileName, $content){
    var_dump($fileName, strlen($content));
    //默认是return true, 会分段,多次执行
    //如果 return false,则执行一次就退出.
    //return false;
}, $trunk_size, $offset);
echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

    $size，读取数据的最大长度，默认为8K = 8192字节
    $offset，偏移文件指针，默认为0，表示从文件头部开始读取。必须大于等于0且小于文件总长度

运行下输出：

$ php async_file.php

done

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(6459)

string(8) "./1.text"
int(0)

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21

会发现了执行了多次，一次一次的异步分段在读取。$size参数设定每一次读取最大的值。
Swoole\Async::write 异步分段写入大内容到文件

Swoole\Async::write是分段读写的。不需要一次性将要写的内容放到内存里，所以只占用少量内存。

我准备了一个1.text的文件，大概有 35k 大小。写入到4.text中。

$content = file_get_contents('./1.text');
Swoole\Async::write("./4.text", $content, -1, function($fileName){
    var_dump($fileName);
});

echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6

运行下输出：

$ php async_file.php
done
string(8) "./4.text"

    1
    2
    3

Swoole\Async::dnsLookup 异步查询DNS

当DNS查询完成时，自动回调指定的callback函数。
当DNS查询失败时，比如域名不存在，回调函数传入的$ip为空

Swoole\Async::dnsLookup("www.baidu.com", function($host, $ip){
    var_dump($host, $ip);
});

Swoole\Async::dnsLookup("www.esd4343.com", function($host, $ip){
    var_dump($host, $ip);
});

echo 'dns done';

    1
    2
    3
    4
    5
    6
    7
    8
    9

执行下：

$ php async.php

dns done

string(13) "www.baidu.com"
string(13) "14.215.177.37"

string(15) "www.esd4343.com"
string(0) ""

    1
    2
    3
    4
    5
    6
    7
    8
    9

异步毫秒定时器
Swoole\Timer::tick 异步毫秒定时器

设置一个间隔时钟定时器，单位是微妙。与after定时器不同的是tick定时器会持续触发，直到调用Swoole\Timer::clear清除。而且可以设置多个相同时间间隔的定时器。

$tmer_id1 = Swoole\Timer::tick(1000, function($timer_id, $params = null){
    echo $timer_id. "timeout\n" . microtime(true);

    //Swoole\Timer::clear($timer_id);
});

//1
var_dump($timer_id1);

// true
var_dump(Swoole\Timer::exists($timer_id1));die;

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

Swoole\Timer::after 异步制定的毫秒时间后执行一次

一个一次性定时器，执行完成后就会销毁,回调函数没有任何参数

$tmer_id2 = Swoole\Timer::after(1000, function(){
     echo "timeout\n" . microtime(true);
});

//2
var_dump($tmer_id2);

// true
var_dump(Swoole\Timer::exists($tmer_id2));die;

    1
    2
    3
    4
    5
    6
    7
    8
    9

Swoole\Timer::clear 删除定时器

使用定时器ID来删除定时器,不能用于清除其他进程的定时器，只作用于当前进程。

$tmer_id1 = Swoole\Timer::tick(1, function($timer_id, $params = null){
    echo $timer_id. "loop" . microtime(true) . PHP_EOL;

    global $a; $a++;

    //1万次后清除
    if ($a >= 10000) {
        Swoole\Timer::clear($timer_id);
    }
});

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

异步MySQL客户端

异步mysql就是异步的去连接数据库。直接上代码。

<?php
/**
 * Created by PhpStorm.
 * User: yangyi
 * Date: 2017/1/5
 * Time: 17:52
 */

$db = new Swoole\Mysql;

//配置文件
$server = array(
    'host' => '127.0.0.1',
    'user' => 'root',
    'password' => '123456',
    'database' => 'user',
);

//concent方法 2个参数，第一个是配置文件，第二个是一个回调函数。
$db->connect($server, function ($db, $result) {
    //$result 连接是否成功，只有为true时才可以执行query查询
    //$result 为false，可以通过`connect_errno`和`connect_error`得到失败的错误码和错误信息
    if ($result === false) {
        var_dump($db->connect_errno, $db->connect_error);
        die;
    }
    $sql = 'select * from ap_room limit 1';

    //query方法就是执行sql的方法
    //第一个参数是sql, 第二个参数是回调函数

    $db->query($sql, function($db, $result) {

        /*
        *  执行失败，$result为false
        *  error属性获得错误信息，errno属性获得错误码
        */
        if ($result === false) {
            var_dump($db->error, $db->errno);
        }

        /*
        * 执行成功
        * SQL为非查询语句(inset,update,delete）$result为true
        * affected_rows 为影响的行数，insert_id 获得
        */
        else if ($result === true ) {
            var_dump($db->affected_rows, $db->insert_id);
        }

        /*
        * 执行成功，SQL为select语句，$result为结果数组
        */
        else {
             var_dump($result);
        }

        //关闭mysql连接
        $db->close();
    });
});

echo 33;
异步IO，分很多种，但凡是IO相关的都可以借助swoole来完成。
异步文件系统IO
Swoole\Async::readFile 异步读取小型文件

Swoole\Async::readFile最大可读取4M的文件，如果要读取超大文件，请使用Swoole\Async::read函数

读取文件一定要先存在，不然报错，我准备一个2.text,内容是123456.

//swoole_async_readfile最大可读取4M的文件
//如果要读取超大文件，请使用swoole_async_read函数
Swoole\Async::readFile("./2.text", function($fileName, $content){
    var_dump($fileName, $content);
});
echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6
    7

运行下输出：

$ php async_file.php
done
string(8) "./2.text"
123456

    1
    2
    3
    4

Swoole\Async::writeFile 异步写入少量内容到文件

Swoole\Async::writeFile最大可写入4M, 文件不存在,会自动创建,写入会从头覆盖原先的内容

//文件不存在,会自动创建,最大可写入4M
//会覆盖原先的内容,从头开始覆盖
Swoole\Async::writeFile("./2.text", 'v', function($fileName){
    var_dump($fileName);
});

echo "done" .PHP_EOL;

//再异步读一下，写入成功没？
Swoole\Async::writeFile("./2.text", 'v', function($fileName){
    var_dump($fileName);
});

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12

运行下输出：

$ php async_file.php
done
string(8) "./2.text"
v23456

    1
    2
    3
    4

可以看到会从头写入，原先的1被v给取代了。暂时不知此从尾部写文件。
Swoole\Async::read 异步分段读取大型文件

异步读大文件，分段读取，每次只读$trunk_size个字节，不会占用太多内存。

我准备了一个1.text的文件，大概有 35k 大小。

$trunk_size = 8192;

$offset = 0

Swoole\Async::read("./1.text", function($fileName, $content){
    var_dump($fileName, strlen($content));
    //默认是return true, 会分段,多次执行
    //如果 return false,则执行一次就退出.
    //return false;
}, $trunk_size, $offset);
echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

    $size，读取数据的最大长度，默认为8K = 8192字节
    $offset，偏移文件指针，默认为0，表示从文件头部开始读取。必须大于等于0且小于文件总长度

运行下输出：

$ php async_file.php

done

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(8192)

string(8) "./1.text"
int(6459)

string(8) "./1.text"
int(0)

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21

会发现了执行了多次，一次一次的异步分段在读取。$size参数设定每一次读取最大的值。
Swoole\Async::write 异步分段写入大内容到文件

Swoole\Async::write是分段读写的。不需要一次性将要写的内容放到内存里，所以只占用少量内存。

我准备了一个1.text的文件，大概有 35k 大小。写入到4.text中。

$content = file_get_contents('./1.text');
Swoole\Async::write("./4.text", $content, -1, function($fileName){
    var_dump($fileName);
});

echo "done" .PHP_EOL;

    1
    2
    3
    4
    5
    6

运行下输出：

$ php async_file.php
done
string(8) "./4.text"

    1
    2
    3

Swoole\Async::dnsLookup 异步查询DNS

当DNS查询完成时，自动回调指定的callback函数。
当DNS查询失败时，比如域名不存在，回调函数传入的$ip为空

Swoole\Async::dnsLookup("www.baidu.com", function($host, $ip){
    var_dump($host, $ip);
});

Swoole\Async::dnsLookup("www.esd4343.com", function($host, $ip){
    var_dump($host, $ip);
});

echo 'dns done';

    1
    2
    3
    4
    5
    6
    7
    8
    9

执行下：

$ php async.php

dns done

string(13) "www.baidu.com"
string(13) "14.215.177.37"

string(15) "www.esd4343.com"
string(0) ""

    1
    2
    3
    4
    5
    6
    7
    8
    9

异步毫秒定时器
Swoole\Timer::tick 异步毫秒定时器

设置一个间隔时钟定时器，单位是微妙。与after定时器不同的是tick定时器会持续触发，直到调用Swoole\Timer::clear清除。而且可以设置多个相同时间间隔的定时器。

$tmer_id1 = Swoole\Timer::tick(1000, function($timer_id, $params = null){
    echo $timer_id. "timeout\n" . microtime(true);

    //Swoole\Timer::clear($timer_id);
});

//1
var_dump($timer_id1);

// true
var_dump(Swoole\Timer::exists($timer_id1));die;

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

Swoole\Timer::after 异步制定的毫秒时间后执行一次

一个一次性定时器，执行完成后就会销毁,回调函数没有任何参数

$tmer_id2 = Swoole\Timer::after(1000, function(){
     echo "timeout\n" . microtime(true);
});

//2
var_dump($tmer_id2);

// true
var_dump(Swoole\Timer::exists($tmer_id2));die;

    1
    2
    3
    4
    5
    6
    7
    8
    9

Swoole\Timer::clear 删除定时器

使用定时器ID来删除定时器,不能用于清除其他进程的定时器，只作用于当前进程。

$tmer_id1 = Swoole\Timer::tick(1, function($timer_id, $params = null){
    echo $timer_id. "loop" . microtime(true) . PHP_EOL;

    global $a; $a++;

    //1万次后清除
    if ($a >= 10000) {
        Swoole\Timer::clear($timer_id);
    }
});

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

异步MySQL客户端

异步mysql就是异步的去连接数据库。直接上代码。

<?php
/**
 * Created by PhpStorm.
 * User: yangyi
 * Date: 2017/1/5
 * Time: 17:52
 */

$db = new Swoole\Mysql;

//配置文件
$server = array(
    'host' => '127.0.0.1',
    'user' => 'root',
    'password' => '123456',
    'database' => 'user',
);

//concent方法 2个参数，第一个是配置文件，第二个是一个回调函数。
$db->connect($server, function ($db, $result) {
    //$result 连接是否成功，只有为true时才可以执行query查询
    //$result 为false，可以通过`connect_errno`和`connect_error`得到失败的错误码和错误信息
    if ($result === false) {
        var_dump($db->connect_errno, $db->connect_error);
        die;
    }
    $sql = 'select * from ap_room limit 1';

    //query方法就是执行sql的方法
    //第一个参数是sql, 第二个参数是回调函数

    $db->query($sql, function($db, $result) {

        /*
        *  执行失败，$result为false
        *  error属性获得错误信息，errno属性获得错误码
        */
        if ($result === false) {
            var_dump($db->error, $db->errno);
        }

        /*
        * 执行成功
        * SQL为非查询语句(inset,update,delete）$result为true
        * affected_rows 为影响的行数，insert_id 获得
        */
        else if ($result === true ) {
            var_dump($db->affected_rows, $db->insert_id);
        }

        /*
        * 执行成功，SQL为select语句，$result为结果数组
        */
        else {
             var_dump($result);
        }

        //关闭mysql连接
        $db->close();
    });
});

echo 33;

echo 33;echo 33;
